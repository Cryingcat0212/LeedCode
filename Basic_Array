# pop elements without dublicate in-place

class Solution:
# regular thought: remove all the dublicated elements by remove / del 
    def removeDuplicates_Re(self, nums: List[int]) -> int:
        if len(nums)<=1: # 特殊情况的处理
            return
        
        nums.sort()
        d = nums[0]
        for r in nums[1::]: # 注意序列倒序遍历的写法 and 从第二个元素开始比较以免第一组被删完
            if r == d:
                nums.remove(r)
            else:
                d = r
        return

# Tow pointers. 把所有不同元素集中在最前面
# 这是JAVA的实现，有空拿python写一写
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    for (int j = 1; j < nums.length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}
    
# Q2: remove given element: 常规思路没什么好说的 主要看一下这一次的two pointers 写法
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}

# Q3：tow sum in list
# 改良版暴力解法 time complicity = O(m!)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums2 = nums[:] # 注意！直接 nums2 = nums的话只是指向同一储存位置，也就是说改的是一个东西
        r = True
        for k in nums:
            if k < 0:
                r =  False
        if r == True:
            for k in nums2:
                if k > 0 > target:
                    nums2.remove(k)
        d = 0
        l = []
        for i in range (0, len(nums2)-1):
            d += 1
            for j in range(d, len(nums2)):
                if nums2[i] + nums2[j] == target:
                    l = [nums.index(nums2[i]), nums.index(nums2[j], nums.index(nums2[i])+1)]
                    break
        return l
        
   # has unknown logic problem
  class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in nums:
            d = target - i
            if d in nums:
                l = [i, nums.index(d,i)] # 直接赋值在循环中会被反复刷新
        return l

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        l = []
        for i in nums:
            d = target - i
            if d in nums[nums.index(i)+1::]: # 有效避免元素重复使用
                l.append(nums.index(i))
                l.append(nums.index(d,nums.index(i)+1))
                break
        return l

# Q4 PLUS ONE 
# 逻辑没问题 1/3部分可以合并
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        if digits[-1] != 9:
            digits[-1] = digits[-1] + 1
        elif digits == [9]:
            digits = [1,0]
        else:
            digits[-1] = digits[-1] + 1
            for i in range(len(digits)-1,0,-1):
                if digits[i] == 10:
                    digits[i] = 0
                    digits[i-1] += 1
                    
        if digits[0] == 10:
            digits[0] = 0
            digits.insert(0,1) # append是在末尾加 O(arg) == 1, insert(index,obj)
        return digits
 # 整体转换为整数然后加一分开 运用列表与str互转之间的性质
 class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        concat = ''
        for num in range(len(digits)):
            numbers = digits[num]
            concat = concat + str(numbers)
        
        plus1 = list(str(int(concat)+1))
            
        return plus1

# ! 列表切片左闭右开 ！

# Q5: move all zeros to the end
   i = len(nums) - 1

    while i >= 0:
        if nums[i] == 0:
            nums.pop(i)
            nums.append(0)
        i -= 1
# related to index, from last to first is always the best

#  我永远都不懂怎么写出杨辉三角
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        triangle = []
        for row_nums in range(0,numRows):
            rows = [None for i in range(row_nums+1)]
            rows[0],rows[-1] = 1,1
            
            for j in range(1, len(rows)-1):
                rows[j] = triangle[row_nums-1][j-1] + triangle[row_nums-1][j]
            triangle.append(rows)
        
        return triangle
# so fking elegant
# 做视野思路
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        minp = 999999
        maxpr = 0
        for i in prices:
            if i < minp:
                minp = i
            elif (i - minp) > maxpr:
                maxpr = i - minp
        return maxpr
